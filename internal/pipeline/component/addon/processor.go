// Copyright 2025 The OpenChoreo Authors
// SPDX-License-Identifier: Apache-2.0

// Package addon handles addon processing for component rendering.
//
// Addons can create new resources and patch existing resources generated by
// the ComponentTypeDefinition.
package addon

import (
	"encoding/json"
	"fmt"
	"maps"
	"strings"

	"github.com/openchoreo/openchoreo/api/v1alpha1"
	"github.com/openchoreo/openchoreo/internal/patch"
	"github.com/openchoreo/openchoreo/internal/template"
)

// Processor handles addon creates and patches.
type Processor struct {
	templateEngine *template.Engine
}

// TargetSpec describes how to locate a resource when applying patches.
type TargetSpec struct {
	Kind    string
	Group   string
	Version string
	Where   string
}

// NewProcessor creates a new addon processor.
func NewProcessor(templateEngine *template.Engine) *Processor {
	return &Processor{
		templateEngine: templateEngine,
	}
}

// ProcessAddons applies all addons to the base resources.
//
// For each addon:
//  1. Apply creates (new resources)
//  2. Apply patches (modify existing resources)
//
// The resources slice is modified in place by patches.
func (p *Processor) ProcessAddons(
	resources []map[string]any,
	addon *v1alpha1.Addon,
	addonContext map[string]any,
) ([]map[string]any, error) {
	// Apply creates first
	var err error
	resources, err = p.ApplyAddonCreates(resources, addon, addonContext)
	if err != nil {
		return nil, err
	}

	// Then apply patches
	err = p.ApplyAddonPatches(resources, addon, addonContext)
	if err != nil {
		return nil, err
	}

	return resources, nil
}

// ApplyAddonCreates renders and adds new resources from addon.spec.creates.
func (p *Processor) ApplyAddonCreates(
	resources []map[string]any,
	addon *v1alpha1.Addon,
	addonContext map[string]any,
) ([]map[string]any, error) {
	for i, createTemplate := range addon.Spec.Creates {
		// Extract template data
		var templateData any
		if err := json.Unmarshal(createTemplate.Template.Raw, &templateData); err != nil {
			return nil, fmt.Errorf("failed to unmarshal create template for addon %s create #%d: %w", addon.Name, i, err)
		}

		// Render template
		rendered, err := p.templateEngine.Render(templateData, addonContext)
		if err != nil {
			return nil, fmt.Errorf("failed to render create template for addon %s create #%d: %w", addon.Name, i, err)
		}

		// Ensure result is an object
		resourceMap, ok := rendered.(map[string]any)
		if !ok {
			return nil, fmt.Errorf("create template must render to object for addon %s create #%d, got %T", addon.Name, i, rendered)
		}

		// Remove omitted fields
		cleanedAny := template.RemoveOmittedFields(resourceMap)
		cleaned, ok := cleanedAny.(map[string]any)
		if !ok {
			return nil, fmt.Errorf("RemoveOmittedFields returned unexpected type %T for addon %s create #%d", cleanedAny, addon.Name, i)
		}

		// Append to resources
		resources = append(resources, cleaned)
	}

	return resources, nil
}

// ApplyAddonPatches applies addon patches to existing resources.
//
// This function handles the orchestration of:
//   - forEach iteration over collections
//   - Resource targeting (finding which resources to patch)
//   - CEL rendering of patch operations and where clauses
//   - Delegating to patch.ApplyPatches for the actual patching
//
// The patch package itself only handles the low-level mechanics of applying
// operations to a single resource.
func (p *Processor) ApplyAddonPatches(
	resources []map[string]any,
	addon *v1alpha1.Addon,
	addonContext map[string]any,
) error {
	for i, addonPatch := range addon.Spec.Patches {
		if err := p.applyPatch(resources, addon.Name, i, addonPatch, addonContext); err != nil {
			return fmt.Errorf("failed to apply addon patch #%d for addon %s: %w", i, addon.Name, err)
		}
	}

	return nil
}

// applyPatch applies a single patch specification to resources.
// Handles forEach iteration, targeting, filtering, and CEL rendering.
func (p *Processor) applyPatch(
	resources []map[string]any,
	addonName string,
	patchIndex int,
	addonPatch v1alpha1.AddonPatch,
	baseContext map[string]any,
) error {
	// Handle forEach iteration if specified
	if addonPatch.ForEach != "" {
		return p.applyPatchWithForEach(resources, addonName, patchIndex, addonPatch, baseContext)
	}

	// No forEach - apply once with base context
	return p.applyPatchOnce(resources, addonName, patchIndex, addonPatch, baseContext)
}

// applyPatchWithForEach handles forEach iteration for a patch.
func (p *Processor) applyPatchWithForEach(
	resources []map[string]any,
	addonName string,
	patchIndex int,
	addonPatch v1alpha1.AddonPatch,
	baseContext map[string]any,
) error {
	// Evaluate the forEach expression to get the list of items
	itemsRaw, err := p.templateEngine.Render(addonPatch.ForEach, baseContext)
	if err != nil {
		return fmt.Errorf("failed to evaluate forEach expression '%s' for addon %s patch #%d: %w", addonPatch.ForEach, addonName, patchIndex, err)
	}

	items, ok := itemsRaw.([]any)
	if !ok {
		return fmt.Errorf("forEach expression '%s' must evaluate to an array for addon %s patch #%d, got %T", addonPatch.ForEach, addonName, patchIndex, itemsRaw)
	}

	// Determine the variable name for each iteration (defaults to "item")
	varName := addonPatch.Var
	if varName == "" {
		varName = "item"
	}

	// Iterate through each item
	for i, item := range items {
		// Shallow clone context for this iteration to avoid cross-iteration contamination.
		// A shallow copy is sufficient because:
		// 1. We only add one new key (the loop variable)
		// 2. The template engine doesn't mutate map values (only reads them)
		// 3. We need isolation so one iteration's loop variable doesn't affect another
		iterContext := maps.Clone(baseContext)
		iterContext[varName] = item

		// Apply patch operations with this iteration's context
		if err := p.applyPatchOnce(resources, addonName, patchIndex, addonPatch, iterContext); err != nil {
			return fmt.Errorf("forEach iteration %d failed: %w", i, err)
		}
	}

	return nil
}

// applyPatchOnce applies a patch to all matching targets with a given context.
func (p *Processor) applyPatchOnce(
	resources []map[string]any,
	addonName string,
	patchIndex int,
	addonPatch v1alpha1.AddonPatch,
	context map[string]any,
) error {
	// 1. Find target resources based on Kind/Group/Version
	target := TargetSpec{
		Kind:    addonPatch.Target.Kind,
		Group:   addonPatch.Target.Group,
		Version: addonPatch.Target.Version,
		Where:   addonPatch.Target.Where,
	}
	targets := FindTargetResources(resources, target)

	if len(targets) == 0 {
		// No matching resources - this is okay, patch is a no-op
		return nil
	}

	// 2. Filter targets using where clause if specified
	if target.Where != "" {
		filtered, err := p.filterTargets(targets, target.Where, context, addonName, patchIndex)
		if err != nil {
			return err
		}
		targets = filtered
	}

	// 3. Render patch operations with CEL
	renderedOps, err := p.renderOperations(addonPatch.Operations, context, addonName, patchIndex)
	if err != nil {
		return err
	}

	// 4. Apply rendered operations to each target using the simple patch function
	for _, target := range targets {
		if err := patch.ApplyPatches(target, renderedOps); err != nil {
			// Extract resource identity for better error message
			kind, _ := target["kind"].(string)
			metadata, _ := target["metadata"].(map[string]any)
			name, _ := metadata["name"].(string)
			resourceID := fmt.Sprintf("%s/%s", kind, name)
			if resourceID == "/" {
				resourceID = "unknown resource"
			}
			return fmt.Errorf("failed to apply patches to %s for addon %s patch #%d: %w", resourceID, addonName, patchIndex, err)
		}
	}

	return nil
}

// filterTargets filters resources based on a where clause.
// The where clause is evaluated as a CEL expression with "resource" bound to each target.
func (p *Processor) filterTargets(
	targets []map[string]any,
	whereClause string,
	baseContext map[string]any,
	addonName string,
	patchIndex int,
) ([]map[string]any, error) {
	filtered := make([]map[string]any, 0, len(targets))

	// Save previous "resource" binding if it exists
	previous, had := baseContext["resource"]

	for _, target := range targets {
		// Bind the current resource for evaluation
		baseContext["resource"] = target

		// Evaluate the where clause
		result, err := p.templateEngine.Render(whereClause, baseContext)
		if err != nil {
			// If this is a "missing data" error, treat as non-match
			if template.IsMissingDataError(err) {
				continue
			}
			// Restore previous binding before returning error
			if had {
				baseContext["resource"] = previous
			} else {
				delete(baseContext, "resource")
			}
			return nil, fmt.Errorf("failed to evaluate where clause '%s' for addon %s patch #%d: %w", whereClause, addonName, patchIndex, err)
		}

		// Check if result is boolean true
		boolResult, ok := result.(bool)
		if !ok {
			// Restore previous binding before returning error
			if had {
				baseContext["resource"] = previous
			} else {
				delete(baseContext, "resource")
			}
			return nil, fmt.Errorf("where clause '%s' must evaluate to boolean for addon %s patch #%d, got %T", whereClause, addonName, patchIndex, result)
		}

		if boolResult {
			filtered = append(filtered, target)
		}
	}

	// Restore previous "resource" binding
	if had {
		baseContext["resource"] = previous
	} else {
		delete(baseContext, "resource")
	}

	return filtered, nil
}

// renderOperations renders all patch operations using CEL.
// Both the path and value of each operation may contain ${...} expressions.
func (p *Processor) renderOperations(
	operations []v1alpha1.JSONPatchOperation,
	context map[string]any,
	addonName string,
	patchIndex int,
) ([]patch.JSONPatchOperation, error) {
	rendered := make([]patch.JSONPatchOperation, len(operations))

	for i, op := range operations {
		// Render the path (which may contain CEL expressions)
		pathValue, err := p.templateEngine.Render(op.Path, context)
		if err != nil {
			return nil, fmt.Errorf("failed to render path '%s' for addon %s patch #%d operation #%d: %w", op.Path, addonName, patchIndex, i, err)
		}

		pathStr, ok := pathValue.(string)
		if !ok {
			return nil, fmt.Errorf("path '%s' must evaluate to string for addon %s patch #%d operation #%d, got %T", op.Path, addonName, patchIndex, i, pathValue)
		}

		// Render the value (unless this is a remove operation)
		var value any
		if op.Op != "remove" {
			// Extract value from RawExtension
			if op.Value != nil && op.Value.Raw != nil {
				if err := json.Unmarshal(op.Value.Raw, &value); err != nil {
					return nil, fmt.Errorf("failed to unmarshal value for addon %s patch #%d operation #%d: %w", addonName, patchIndex, i, err)
				}

				// Render the value (which may contain CEL expressions)
				value, err = p.templateEngine.Render(value, context)
				if err != nil {
					return nil, fmt.Errorf("failed to render value for addon %s patch #%d operation #%d: %w", addonName, patchIndex, i, err)
				}
			}
		}

		rendered[i] = patch.JSONPatchOperation{
			Op:    op.Op,
			Path:  pathStr,
			Value: value,
		}
	}

	return rendered, nil
}

// FindTargetResources filters resources based on Kind, Group, and Version.
//
// Matching is done in order:
//  1. If target.Kind is set, resource.kind must match
//  2. If target.Group is set, the group portion of resource.apiVersion must match
//  3. If target.Version is set, the version portion of resource.apiVersion must match
//
// An empty field in the target spec means "match any value".
//
// apiVersion is split into group/version:
//   - "apps/v1" → group="apps", version="v1"
//   - "v1" → group="", version="v1" (core API)
//
// Note: Additional filtering (e.g., by name or custom where clauses) should be
// done by the caller after calling this function.
func FindTargetResources(resources []map[string]any, target TargetSpec) []map[string]any {
	matches := make([]map[string]any, 0, len(resources))
	for _, resource := range resources {
		// Match Kind
		if target.Kind != "" {
			if kind, ok := resource["kind"].(string); !ok || kind != target.Kind {
				continue
			}
		}

		// Match Group and Version (extracted from apiVersion)
		group := ""
		version := ""
		if gv, ok := resource["apiVersion"].(string); ok {
			group, version = splitAPIVersion(gv)
		}
		if target.Group != "" && group != target.Group {
			continue
		}
		if target.Version != "" && version != target.Version {
			continue
		}

		matches = append(matches, resource)
	}
	return matches
}

// splitAPIVersion separates a Kubernetes apiVersion into group and version parts.
//
// Examples:
//   - "apps/v1" → ("apps", "v1")
//   - "v1" → ("", "v1")         // Core API group
//   - "" → ("", "")
func splitAPIVersion(apiVersion string) (group, version string) {
	if apiVersion == "" {
		return "", ""
	}
	if strings.Contains(apiVersion, "/") {
		parts := strings.SplitN(apiVersion, "/", 2)
		return parts[0], parts[1]
	}
	// No slash means it's a core API (e.g., "v1")
	return "", apiVersion
}
