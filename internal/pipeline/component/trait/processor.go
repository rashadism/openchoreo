// Copyright 2025 The OpenChoreo Authors
// SPDX-License-Identifier: Apache-2.0

// Package trait handles trait processing for component rendering.
//
// Traits can create new resources and patch existing resources generated by
// the ComponentType.
package trait

import (
	"encoding/json"
	"fmt"
	"maps"
	"strings"

	"github.com/openchoreo/openchoreo/api/v1alpha1"
	"github.com/openchoreo/openchoreo/internal/patch"
	"github.com/openchoreo/openchoreo/internal/pipeline/component/renderer"
	"github.com/openchoreo/openchoreo/internal/template"
)

// Processor handles trait creates and patches.
type Processor struct {
	templateEngine *template.Engine
}

// TargetSpec describes how to locate a resource when applying patches.
type TargetSpec struct {
	Kind        string
	Group       string
	Version     string
	Where       string
	TargetPlane string
}

// NewProcessor creates a new trait processor.
func NewProcessor(templateEngine *template.Engine) *Processor {
	return &Processor{
		templateEngine: templateEngine,
	}
}

// ProcessTraits applies all traits to the base resources.
//
// For each trait:
//   - Apply creates (new resources with targetPlane)
//   - Apply patches (modify existing resources, respecting targetPlane)
func (p *Processor) ProcessTraits(
	resources []renderer.RenderedResource,
	trait *v1alpha1.Trait,
	traitContext map[string]any,
) ([]renderer.RenderedResource, error) {
	// Apply creates first
	var err error
	resources, err = p.ApplyTraitCreates(resources, trait, traitContext)
	if err != nil {
		return nil, err
	}

	// Then apply patches
	err = p.ApplyTraitPatches(resources, trait, traitContext)
	if err != nil {
		return nil, err
	}

	return resources, nil
}

// ApplyTraitCreates renders and adds new resources from trait.spec.creates with targetPlane metadata.
// Supports includeWhen for conditional creation and forEach for generating multiple resources.
func (p *Processor) ApplyTraitCreates(
	resources []renderer.RenderedResource,
	trait *v1alpha1.Trait,
	traitContext map[string]any,
) ([]renderer.RenderedResource, error) {
	for i, createTemplate := range trait.Spec.Creates {
		createPath := fmt.Sprintf("trait %s create #%d", trait.Name, i)

		// Check includeWhen condition using shared helper
		include, err := renderer.ShouldInclude(p.templateEngine, createTemplate.IncludeWhen, traitContext)
		if err != nil {
			return nil, fmt.Errorf("failed to evaluate includeWhen for %s: %w", createPath, err)
		}
		if !include {
			continue
		}

		// Handle forEach or single render
		if createTemplate.ForEach != "" {
			itemContexts, err := renderer.EvalForEach(p.templateEngine, createTemplate.ForEach, createTemplate.Var, traitContext)
			if err != nil {
				return nil, fmt.Errorf("failed to evaluate forEach for %s: %w", createPath, err)
			}
			for _, itemContext := range itemContexts {
				rendered, err := p.renderSingleCreate(createTemplate, itemContext, createPath)
				if err != nil {
					return nil, err
				}
				resources = append(resources, rendered)
			}
		} else {
			rendered, err := p.renderSingleCreate(createTemplate, traitContext, createPath)
			if err != nil {
				return nil, err
			}
			resources = append(resources, rendered)
		}
	}

	return resources, nil
}

// renderSingleCreate renders a single TraitCreate template and returns a RenderedResource.
func (p *Processor) renderSingleCreate(
	create v1alpha1.TraitCreate,
	context map[string]any,
	path string,
) (renderer.RenderedResource, error) {
	var templateData any
	if err := json.Unmarshal(create.Template.Raw, &templateData); err != nil {
		return renderer.RenderedResource{}, fmt.Errorf("failed to unmarshal create template for %s: %w", path, err)
	}

	rendered, err := p.templateEngine.Render(templateData, context)
	if err != nil {
		return renderer.RenderedResource{}, fmt.Errorf("failed to render create template for %s: %w", path, err)
	}

	resourceMap, ok := rendered.(map[string]any)
	if !ok {
		return renderer.RenderedResource{}, fmt.Errorf("create template must render to object for %s, got %T", path, rendered)
	}

	cleanedAny := template.RemoveOmittedFields(resourceMap)
	cleaned, ok := cleanedAny.(map[string]any)
	if !ok {
		return renderer.RenderedResource{}, fmt.Errorf("RemoveOmittedFields returned unexpected type %T for %s", cleanedAny, path)
	}

	return renderer.RenderedResource{
		Resource:    cleaned,
		TargetPlane: create.TargetPlane,
	}, nil
}

// ApplyTraitPatches applies trait patches to existing resources.
//
// This function handles the orchestration of:
//   - forEach iteration over collections (arrays and maps)
//   - Resource targeting (finding which resources to patch, respecting targetPlane)
//   - CEL rendering of patch operations and where clauses
//   - Delegating to patch.ApplyPatches for the actual patching
//
// For forEach with maps, keys are iterated in sorted order with each item having
// .key and .value fields.
//
// The patch package itself only handles the low-level mechanics of applying
// operations to a single resource.
func (p *Processor) ApplyTraitPatches(
	resources []renderer.RenderedResource,
	trait *v1alpha1.Trait,
	traitContext map[string]any,
) error {
	for i, traitPatch := range trait.Spec.Patches {
		if err := p.applyPatch(resources, trait.Name, i, traitPatch, traitContext); err != nil {
			return fmt.Errorf("failed to apply trait patch #%d for trait %s: %w", i, trait.Name, err)
		}
	}

	return nil
}

// applyPatch applies a single patch specification to resources.
// Handles forEach iteration, targeting, filtering, targetPlane matching, and CEL rendering.
func (p *Processor) applyPatch(
	resources []renderer.RenderedResource,
	traitName string,
	patchIndex int,
	traitPatch v1alpha1.TraitPatch,
	baseContext map[string]any,
) error {
	// Handle forEach iteration if specified
	if traitPatch.ForEach != "" {
		return p.applyPatchWithForEach(resources, traitName, patchIndex, traitPatch, baseContext)
	}

	// No forEach - apply once with base context
	return p.applyPatchOnce(resources, traitName, patchIndex, traitPatch, baseContext)
}

// applyPatchWithForEach handles forEach iteration for a patch.
// Supports both arrays and maps. For maps, items are {key, value} entries sorted by key.
func (p *Processor) applyPatchWithForEach(
	resources []renderer.RenderedResource,
	traitName string,
	patchIndex int,
	traitPatch v1alpha1.TraitPatch,
	baseContext map[string]any,
) error {
	// Evaluate the forEach expression to get the list of items
	itemsRaw, err := p.templateEngine.Render(traitPatch.ForEach, baseContext)
	if err != nil {
		return fmt.Errorf("failed to evaluate forEach expression '%s' for trait %s patch #%d: %w", traitPatch.ForEach, traitName, patchIndex, err)
	}

	// Convert result to iterable items (supports arrays and maps)
	items, err := renderer.ToIterableItems(itemsRaw)
	if err != nil {
		return fmt.Errorf("invalid forEach result for trait %s patch #%d: %w", traitName, patchIndex, err)
	}

	// Determine the variable name for each iteration (defaults to "item")
	varName := traitPatch.Var
	if varName == "" {
		varName = "item"
	}

	// Iterate through each item
	for i, item := range items {
		// Shallow clone context for this iteration to avoid cross-iteration contamination.
		// A shallow copy is sufficient because:
		//   - We only add one new key (the loop variable)
		//   - The template engine doesn't mutate map values (only reads them)
		//   - We need isolation so one iteration's loop variable doesn't affect another
		iterContext := maps.Clone(baseContext)
		iterContext[varName] = item

		// Apply patch operations with this iteration's context
		if err := p.applyPatchOnce(resources, traitName, patchIndex, traitPatch, iterContext); err != nil {
			return fmt.Errorf("forEach iteration %d failed: %w", i, err)
		}
	}

	return nil
}

// applyPatchOnce applies a patch to all matching targets with a given context.
// Respects targetPlane - only patches resources in the same plane.
func (p *Processor) applyPatchOnce(
	resources []renderer.RenderedResource,
	traitName string,
	patchIndex int,
	traitPatch v1alpha1.TraitPatch,
	context map[string]any,
) error {
	// Find target resources based on targetPlane and Kind/Group/Version
	target := TargetSpec{
		Kind:        traitPatch.Target.Kind,
		Group:       traitPatch.Target.Group,
		Version:     traitPatch.Target.Version,
		Where:       traitPatch.Target.Where,
		TargetPlane: traitPatch.TargetPlane,
	}
	matchedResources := FindTargetResources(resources, target)

	if len(matchedResources) == 0 {
		// No matching resources - this is okay, patch is a no-op
		return nil
	}

	// Filter targets using where clause if specified
	var targets []renderer.RenderedResource
	if target.Where != "" {
		filtered, err := p.filterTargets(matchedResources, target.Where, context, traitName, patchIndex)
		if err != nil {
			return err
		}
		targets = filtered
	} else {
		targets = matchedResources
	}

	// Render patch operations with CEL
	renderedOps, err := p.renderOperations(traitPatch.Operations, context, traitName, patchIndex)
	if err != nil {
		return err
	}

	// Apply rendered operations to each target using the simple patch function
	// Note: patches modify the Resource field in-place
	for _, rr := range targets {
		if err := patch.ApplyPatches(rr.Resource, renderedOps); err != nil {
			// Extract resource identity for better error message
			kind, _ := rr.Resource["kind"].(string)
			metadata, _ := rr.Resource["metadata"].(map[string]any)
			name, _ := metadata["name"].(string)
			resourceID := fmt.Sprintf("%s/%s", kind, name)
			if resourceID == "/" {
				resourceID = "unknown resource"
			}
			return fmt.Errorf("failed to apply patches to %s for trait %s patch #%d: %w", resourceID, traitName, patchIndex, err)
		}
	}

	return nil
}

// filterTargets filters resources based on a where clause.
// The where clause is evaluated as a CEL expression with "resource" bound to each target's Resource field.
func (p *Processor) filterTargets(
	targets []renderer.RenderedResource,
	whereClause string,
	baseContext map[string]any,
	traitName string,
	patchIndex int,
) ([]renderer.RenderedResource, error) {
	filtered := make([]renderer.RenderedResource, 0, len(targets))

	// Save previous "resource" binding if it exists
	previous, had := baseContext["resource"]

	for _, rr := range targets {
		// Bind the current resource for evaluation
		baseContext["resource"] = rr.Resource

		// Evaluate the where clause
		result, err := p.templateEngine.Render(whereClause, baseContext)
		if err != nil {
			// Restore previous binding before returning error
			if had {
				baseContext["resource"] = previous
			} else {
				delete(baseContext, "resource")
			}
			return nil, fmt.Errorf("failed to evaluate where clause '%s' for trait %s patch #%d: %w", whereClause, traitName, patchIndex, err)
		}

		// Check if result is boolean true
		boolResult, ok := result.(bool)
		if !ok {
			// Restore previous binding before returning error
			if had {
				baseContext["resource"] = previous
			} else {
				delete(baseContext, "resource")
			}
			return nil, fmt.Errorf("where clause '%s' must evaluate to boolean for trait %s patch #%d, got %T", whereClause, traitName, patchIndex, result)
		}

		if boolResult {
			filtered = append(filtered, rr)
		}
	}

	// Restore previous "resource" binding
	if had {
		baseContext["resource"] = previous
	} else {
		delete(baseContext, "resource")
	}

	return filtered, nil
}

// renderOperations renders all patch operations using CEL.
// Both the path and value of each operation may contain ${...} expressions.
func (p *Processor) renderOperations(
	operations []v1alpha1.JSONPatchOperation,
	context map[string]any,
	traitName string,
	patchIndex int,
) ([]patch.JSONPatchOperation, error) {
	rendered := make([]patch.JSONPatchOperation, len(operations))

	for i, op := range operations {
		// Render the path (which may contain CEL expressions)
		pathValue, err := p.templateEngine.Render(op.Path, context)
		if err != nil {
			return nil, fmt.Errorf("failed to render path '%s' for trait %s patch #%d operation #%d: %w", op.Path, traitName, patchIndex, i, err)
		}

		pathStr, ok := pathValue.(string)
		if !ok {
			return nil, fmt.Errorf("path '%s' must evaluate to string for trait %s patch #%d operation #%d, got %T", op.Path, traitName, patchIndex, i, pathValue)
		}

		// Render the value (unless this is a remove operation)
		var value any
		if op.Op != "remove" {
			// Extract value from RawExtension
			if op.Value != nil && op.Value.Raw != nil {
				if err := json.Unmarshal(op.Value.Raw, &value); err != nil {
					return nil, fmt.Errorf("failed to unmarshal value for trait %s patch #%d operation #%d: %w", traitName, patchIndex, i, err)
				}

				// Render the value (which may contain CEL expressions)
				value, err = p.templateEngine.Render(value, context)
				if err != nil {
					return nil, fmt.Errorf("failed to render value for trait %s patch #%d operation #%d: %w", traitName, patchIndex, i, err)
				}
			}
		}

		rendered[i] = patch.JSONPatchOperation{
			Op:    op.Op,
			Path:  pathStr,
			Value: value,
		}
	}

	return rendered, nil
}

// FindTargetResources filters resources based on TargetPlane, Kind, Group, and Version.
//
// Matching rules:
//   - If target.TargetPlane is set, resource.TargetPlane must match
//   - If target.Kind is set, resource.kind must match
//   - If target.Group is set, the group portion of resource.apiVersion must match
//   - If target.Version is set, the version portion of resource.apiVersion must match
//
// An empty field in the target spec means "match any value".
//
// apiVersion is split into group/version:
//   - "apps/v1" → group="apps", version="v1"
//   - "v1" → group="", version="v1" (core API)
//
// Note: Additional filtering (e.g., by name or custom where clauses) should be
// done by the caller after calling this function.
func FindTargetResources(resources []renderer.RenderedResource, target TargetSpec) []renderer.RenderedResource {
	matches := make([]renderer.RenderedResource, 0, len(resources))
	for _, rr := range resources {
		// Match TargetPlane
		if target.TargetPlane != "" && rr.TargetPlane != target.TargetPlane {
			continue
		}

		resource := rr.Resource

		// Match Kind
		if target.Kind != "" {
			if kind, ok := resource["kind"].(string); !ok || kind != target.Kind {
				continue
			}
		}

		// Match Group and Version (extracted from apiVersion)
		group := ""
		version := ""
		if gv, ok := resource["apiVersion"].(string); ok {
			group, version = splitAPIVersion(gv)
		}
		if target.Group != "" && group != target.Group {
			continue
		}
		if target.Version != "" && version != target.Version {
			continue
		}

		matches = append(matches, rr)
	}
	return matches
}

// splitAPIVersion separates a Kubernetes apiVersion into group and version parts.
//
// Examples:
//   - "apps/v1" → ("apps", "v1")
//   - "v1" → ("", "v1")         // Core API group
//   - "" → ("", "")
func splitAPIVersion(apiVersion string) (group, version string) {
	if apiVersion == "" {
		return "", ""
	}
	if strings.Contains(apiVersion, "/") {
		parts := strings.SplitN(apiVersion, "/", 2)
		return parts[0], parts[1]
	}
	// No slash means it's a core API (e.g., "v1")
	return "", apiVersion
}
