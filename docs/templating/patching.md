# Patching

This guide explains how to use the patching system in OpenChoreo Traits to modify resources generated by ComponentTypes. The patching engine extends standard JSON Patch (RFC 6902) with powerful features like array filtering and automatic parent creation.

## Overview

Traits can modify existing resources using patches, which are JSON Patch operations enhanced with:
- Array filtering using JSONPath-like syntax
- Automatic parent map creation
- CEL-based resource targeting
- forEach iteration support

## Basic Patch Structure

Patches are defined in the Trait's `spec.patches` section:

```yaml
apiVersion: v1alpha1
kind: Trait
metadata:
  name: monitoring-sidecar
spec:
  patches:
    - target:
        kind: Deployment
        group: apps
        version: v1
      targetPlane: dataplane
      operations:
        - op: add
          path: /spec/template/spec/containers/-
          value:
            name: prometheus-exporter
            image: prom/node-exporter:latest
            ports:
            - containerPort: 9100
```

## CEL Expression Support

CEL expressions (enclosed in `${...}`) can be used in the following patch fields:

- **`forEach`** - Iterate over lists from parameters or metadata
  ```yaml
  forEach: ${parameters.environments}
  ```

- **`where`** - Conditionally apply patches based on resource properties
  ```yaml
  where: ${resource.spec.replicas > 1}
  ```

- **`path`** - Dynamic path segments and array filter conditions
  ```yaml
  path: /data/${env.name}
  path: /spec/containers[?(@.name=='${metadata.name}')]/env/-
  ```

- **`value`** - The value to set. Can be:

  Literal value:
  ```yaml
  value: "enabled"
  ```

  String interpolation:
  ```yaml
  value: ${metadata.name}-sidecar
  ```

  Structure with embedded CEL:
  ```yaml
  value:
    name: ${parameters.volumeName}
    persistentVolumeClaim:
      claimName: ${metadata.name}-pvc
  ```

  Standalone CEL expression:
  ```yaml
  value: ${configurations.toContainerEnvFrom(container.key)}
  ```

## Supported Operations

### add
Adds a value at the specified path. Creates parent maps automatically if they don't exist.

```yaml
# Add a new label
- op: add
  path: /metadata/labels/monitoring
  value: "enabled"

# Append to array
- op: add
  path: /spec/containers/-
  value:
    name: sidecar
    image: sidecar:latest

# Create nested structure (auto-creates parents)
- op: add
  path: /metadata/annotations/example.com~1version
  value: "v2.0"
```

### replace
Replaces an existing value. The path must exist.

```yaml
# Replace a value
- op: replace
  path: /spec/replicas
  value: 3

# Replace array element
- op: replace
  path: /spec/containers/0/image
  value: nginx:latest
```

### remove
Removes a value at the path. No-op if path doesn't exist (idempotent).

```yaml
# Remove a label
- op: remove
  path: /metadata/labels/deprecated

# Remove array element
- op: remove
  path: /spec/containers/1
```

## Array Filtering

Use JSONPath-like syntax to target specific array elements:

### Basic Filtering

```yaml
# Target container by name
- op: add
  path: /spec/template/spec/containers[?(@.name=='app')]/env/-
  value:
    name: MONITORING
    value: enabled

# Target volume by name
- op: replace
  path: /spec/template/spec/volumes[?(@.name=='data')]/emptyDir
  value:
    sizeLimit: 10Gi
```

### Nested Field Filters

```yaml
# Filter by image field, navigate to ports
- op: add
  path: /spec/containers[?(@.image=='nginx:latest')]/ports/-
  value:
    containerPort: 8080

# Filter using nested field path (dot notation)
- op: replace
  path: /spec/containers[?(@.resources.limits.memory=='2Gi')]/image
  value: app:high-mem-v2
```

### Filter Limitations

**Currently supported**: Only simple equality filters of the form `@.field.path=='value'`

```yaml
# Supported - simple field equality
- op: add
  path: /spec/containers[?(@.name=='app')]/env/-
  value:
    name: VERSION
    value: "v2"

# Supported - nested field equality (using dot notation)
- op: add
  path: /spec/volumes[?(@.configMap.name=='app-config')]/configMap/defaultMode
  value: 0644
```

**Not supported**: Multiple conditions (`&&`, `||`), operators like `contains`, array indexing in filters (`@.ports[0]`), or existence checks (`@.ports`).

### Wildcard `[*]`

The `[*]` selector matches **all elements** of an array, expanding the path into one target per element. This is useful when you need to apply a patch across all items without knowing their count or filtering by a field.

```yaml
# Replace a field in every rule
- op: replace
  path: /spec/rules/[*]/host
  value: "new.example.com"

# Append to every rule's backendRefs
- op: add
  path: /spec/rules/[*]/backendRefs/-
  value:
    name: new-backend
    port: 8080
```

Wildcards compose with filters to target nested elements across all parents:

```yaml
# Replace matching backendRefs across ALL rules (not just rules/0)
- op: replace
  path: /spec/rules/[*]/backendRefs/[?(@.name=='${metadata.componentName}')]
  value:
    group: gateway.kgateway.dev
    kind: Backend
    name: ${metadata.componentName}-api-gw-backend
```

Like filters, `[*]` returns an error if the array is empty or the path doesn't point to an array.

## Path Resolution Behavior

OpenChoreo extends RFC 6902 JSON Patch to provide Kubernetes-friendly behavior:

| Path Type | Operation | Behavior | RFC 6902 |
|-----------|-----------|----------|----------|
| **Filter** `[?(...)]` | add, replace, remove | **Error** if selector matches zero elements | Standard |
| **Wildcard** `[*]` | add, replace, remove | **Error** if array is empty or path is not an array | Extended |
| **Map key** | add | **Auto-create** parent maps if missing | Extended |
| **Map key** | replace | **Error** if target doesn't exist | Standard |
| **Map key** | remove | **Idempotent** - no error if key doesn't exist | Extended |
| **Array index** | add, replace, remove | **Error** if index out of bounds | Standard |

### Extensions to RFC 6902

OpenChoreo makes two deliberate extensions to RFC 6902:

1. **Auto-create parent maps** - `add` operations automatically create missing parent objects, reducing boilerplate in Trait patches
2. **Idempotent map key removal** - `remove` operations on map keys succeed silently if the key doesn't exist, useful for cleanup operations

These extensions match Kubernetes Strategic Merge Patch behavior. The map key auto-creation and idempotent removal are similar to using `evanphx/json-patch` with:
- `EnsurePathExistsOnAdd: true`
- `AllowMissingPathOnRemove: true`

**Note on Arrays**: All array index operations (add, replace, remove) error on out-of-bounds indices, as this likely indicates an error in the patch configuration or a mismatch between the patch and the ComponentType output. For dynamic array operations, use filters (e.g., `[?(@.name=='sidecar')]`) instead of positional indices.

### Examples

```yaml
# Filter path - ERRORS if no container named 'app' exists
- op: add
  path: /spec/containers[?(@.name=='app')]/env/-
  value: {name: VAR, value: val}

# Map key path - AUTO-CREATES /spec/monitoring if missing
- op: add
  path: /spec/monitoring/enabled
  value: true

# Map key removal - IDEMPOTENT (no error if key missing)
- op: remove
  path: /metadata/labels/deprecated-feature

# Array index - ERRORS if index out of bounds
- op: add
  path: /spec/containers/2  # Errors if less than 3 containers
  value: {name: sidecar, image: sidecar:v1}

- op: remove
  path: /spec/containers/2  # Errors if less than 3 containers
```

### Comparison with Kubernetes API Server

The Kubernetes API server's JSON Patch implementation strictly follows RFC 6902 and will **error** on both missing parents and missing remove targets. However, Kubernetes users typically use **Strategic Merge Patch** (the default for `kubectl patch`), which auto-creates parents similar to OpenChoreo.

OpenChoreo's behavior is designed for Trait authors who expect Kubernetes-like convenience without needing to write conditional logic for path existence checks.

## Resource Targeting

### Basic Targeting

The `target` spec requires `kind`, `group`, and `version` fields. The `targetPlane` field is optional and defaults to `"dataplane"`:

```yaml
patches:
  # Patch apps/v1 Deployment in dataplane
  - target:
      kind: Deployment   # Required: Resource kind
      group: apps        # Required: API group (use "" for core resources)
      version: v1        # Required: API version
      where: ""          # Optional: CEL expression to filter resources
    targetPlane: dataplane  # Optional: defaults to "dataplane" if not specified
    operations:
      - op: add
        path: /metadata/labels/patched
        value: "true"

  # Patch core v1 Service (note: group is explicitly "")
  - target:
      kind: Service
      group: ""          # Empty string for core API resources
      version: v1
    # targetPlane omitted - defaults to "dataplane"
    operations:
      - op: add
        path: /metadata/annotations/patched
        value: "true"
```

**Key Points:**
- `kind`, `group`, and `version` are **always required**
- For core API resources (Service, ConfigMap, Secret), use `group: ""`
- `targetPlane` is optional and defaults to `"dataplane"` if not specified
- `where` clause is optional for filtering resources

**Design Rationale:**
- **Why `group` is required**: Making `group` required eliminates ambiguity. Empty string `""` has semantic meaning (core API resources like Service, ConfigMap, Secret), so we require explicit specification. This ensures patches target the intended resources; omitting the group could result in not matching any resources at all.
- **Why `targetPlane` defaults to "dataplane"**: Most resources are deployed to the dataplane, with few (if any) on the observability plane. Defaulting to the common case reduces verbosity while allowing explicit specification when needed.

### CEL-Based Filtering

Use `where` clause with CEL expressions to target resources conditionally:

```yaml
patches:
  - target:
      kind: Deployment
      group: apps
      version: v1
      where: ${resource.spec.replicas > 1}  # Only multi-replica deployments
    targetPlane: dataplane
    operations:
      - op: add
        path: /metadata/annotations/ha-mode
        value: "true"

  - target:
      kind: Service
      group: ""          # Core API
      version: v1
      where: ${resource.spec.type == 'LoadBalancer'}
    targetPlane: dataplane
    operations:
      - op: add
        path: /metadata/annotations/external
        value: "true"
```

## ForEach Iteration

Apply patches iteratively over a list:

```yaml
patches:
  - target:
      kind: ConfigMap
      group: ""
      version: v1
    targetPlane: dataplane
    forEach: ${parameters.environments}
    var: env
    operations:
      - op: add
        path: /data/${env.name}
        value: ${env.value}

  - target:
      kind: Deployment
      group: apps
      version: v1
    targetPlane: dataplane
    forEach: ${parameters.extraPorts}
    var: port
    operations:
      - op: add
        path: /spec/template/spec/containers[?(@.name=='app')]/ports/-
        value:
          containerPort: ${port.number}
          name: ${port.name}
```

## RFC 6901 Escaping

JSON Patch uses JSON Pointer (RFC 6901) for path references. The specification **requires** escaping special characters in path segments:

- `~` becomes `~0`
- `/` becomes `~1`

This is particularly important for Kubernetes resource paths that contain these characters (e.g., `kubernetes.io/ingress-class` annotations).

```yaml
# Path with / character (Kubernetes annotation)
- op: add
  path: /metadata/annotations/kubernetes.io~1ingress-class
  value: nginx

# Path with ~ character
- op: add
  path: /data/config~0backup
  value: backup-data

# Complex example with both
- op: add
  path: /metadata/labels/app.kubernetes.io~1managed~0by
  value: openchoreo
```

## Advanced Examples

### Add Sidecar Container

```yaml
apiVersion: v1alpha1
kind: Trait
metadata:
  name: logging-sidecar
spec:
  patches:
    - target:
        group: apps
        version: v1
        kind: Deployment
      operations:
        # Add sidecar container
        - op: add
          path: /spec/template/spec/containers/-
          value:
            name: fluentd
            image: fluent/fluentd:v1.14
            volumeMounts:
            - name: logs
              mountPath: /var/log

        # Add shared volume
        - op: add
          path: /spec/template/spec/volumes/-
          value:
            name: logs
            emptyDir: {}

        # Mount log volume to main container
        - op: add
          path: /spec/template/spec/containers[?(@.name=='${metadata.name}')]/volumeMounts/-
          value:
            name: logs
            mountPath: /app/logs
```

### Modify Service Ports

```yaml
apiVersion: v1alpha1
kind: Trait
metadata:
  name: metrics-port
spec:
  patches:
    - target:
        kind: Service
      operations:
        # Add metrics port to service
        - op: add
          path: /spec/ports/-
          value:
            name: metrics
            port: 9090
            targetPort: metrics
            protocol: TCP

        # Add selector for metrics
        - op: add
          path: /spec/selector/metrics
          value: enabled
```

### Conditional Resource Limits

```yaml
apiVersion: v1alpha1
kind: Trait
metadata:
  name: resource-optimizer
spec:
  schema:
    tier: "string | enum=small,medium,large default=small"

  patches:
    - target:
        group: apps
        version: v1
        kind: Deployment
        where: ${parameters.tier == 'small'}
      operations:
        - op: add
          path: /spec/template/spec/containers[?(@.name=='${metadata.name}')]/resources/limits/memory
          value: 512Mi
        - op: add
          path: /spec/template/spec/containers[?(@.name=='${metadata.name}')]/resources/limits/cpu
          value: 500m
        - op: add
          path: /spec/template/spec/containers[?(@.name=='${metadata.name}')]/resources/requests/memory
          value: 256Mi
        - op: add
          path: /spec/template/spec/containers[?(@.name=='${metadata.name}')]/resources/requests/cpu
          value: 250m

    - target:
        group: apps
        version: v1
        kind: Deployment
        where: ${parameters.tier == 'large'}
      operations:
        - op: add
          path: /spec/template/spec/containers[?(@.name=='${metadata.name}')]/resources/limits/memory
          value: 4Gi
        - op: add
          path: /spec/template/spec/containers[?(@.name=='${metadata.name}')]/resources/limits/cpu
          value: 2000m
        - op: add
          path: /spec/template/spec/containers[?(@.name=='${metadata.name}')]/resources/requests/memory
          value: 2Gi
        - op: add
          path: /spec/template/spec/containers[?(@.name=='${metadata.name}')]/resources/requests/cpu
          value: 1000m
```

### Network Policy Addition

```yaml
apiVersion: v1alpha1
kind: Trait
metadata:
  name: network-isolation
spec:
  patches:
    # First ensure NetworkPolicy exists via 'creates'
    # Then patch it based on configuration
    - target:
        group: networking.k8s.io
        version: v1
        kind: NetworkPolicy
        name: ${metadata.name}-netpol
      operations:
        # Add ingress rules
        - op: add
          path: /spec/ingress/-
          value:
            from:
            - podSelector:
                matchLabels:
                  app: frontend
            ports:
            - protocol: TCP
              port: 8080

        # Add egress rules
        - op: add
          path: /spec/egress/-
          value:
            to:
            - podSelector:
                matchLabels:
                  app: database
            ports:
            - protocol: TCP
              port: 5432
```

## Common Patterns

### Safe Label Addition

```yaml
# Good - adds individual labels without affecting existing ones
- op: add
  path: /metadata/labels/monitoring
  value: enabled
- op: add
  path: /metadata/labels/trait
  value: ${metadata.name}

# Bad - replaces all existing labels
- op: replace
  path: /metadata/labels
  value:
    monitoring: enabled
    trait: ${metadata.name}
```

### Conditional Container Environment

```yaml
# Add environment variables based on configuration
- target:
    group: apps
    version: v1
    kind: Deployment
  forEach: ${parameters.envVars}
  var: envVar
  operations:
    - op: add
      path: /spec/template/spec/containers[?(@.name=='${parameters.containerName}')]/env/-
      value:
        name: ${envVar.name}
        value: ${envVar.value}
```

### Volume Mount Injection

```yaml
# Add volume mounts to specific containers
- op: add
  path: /spec/template/spec/volumes/-
  value:
    name: config
    configMap:
      name: ${metadata.name}-config

- op: add
  path: /spec/template/spec/containers[?(@.name=='app')]/volumeMounts/-
  value:
    name: config
    mountPath: /etc/config
    readOnly: true
```

### Service Mesh Annotations

```yaml
# Add Istio sidecar annotations
- op: add
  path: /spec/template/metadata/annotations/sidecar.istio.io~1inject
  value: "true"
- op: add
  path: /spec/template/metadata/annotations/sidecar.istio.io~1proxyCPU
  value: "100m"
- op: add
  path: /spec/template/metadata/annotations/sidecar.istio.io~1proxyMemory
  value: "128Mi"
```

### Use Filters and Wildcards for Explicit Targeting

```yaml
# Good - explicit container selection
- op: add
  path: /spec/containers[?(@.name=='app')]/env/-
  value: {name: VAR, value: val}

# Good - target all array elements with wildcard
- op: replace
  path: /spec/rules/[*]/backendRefs/[?(@.name=='my-svc')]
  value: {name: my-svc, port: 443}

# Bad - assumes container position
- op: add
  path: /spec/containers/0/env/-
  value: {name: VAR, value: val}
```

### Use Proper Escaping

```yaml
# Good - escaped annotation
- op: add
  path: /metadata/annotations/example.com~1version
  value: v1

# Bad - unescaped will fail
- op: add
  path: /metadata/annotations/example.com/version
  value: v1
```
