// Copyright 2025 The OpenChoreo Authors
// SPDX-License-Identifier: Apache-2.0

package framework

import (
	"bytes"
	"fmt"
	"os/exec"
	"strings"

	. "github.com/onsi/ginkgo/v2" //nolint:revive
)

// Kubectl executes an arbitrary kubectl command with the given context.
// Returns trimmed combined output (stdout+stderr) and any error.
func Kubectl(kubeContext string, args ...string) (string, error) {
	cmdArgs := append([]string{"--context", kubeContext}, args...)
	cmd := exec.Command("kubectl", cmdArgs...)
	fmt.Fprintf(GinkgoWriter, "running: kubectl %s\n", strings.Join(cmdArgs, " "))
	out, err := cmd.CombinedOutput()
	output := strings.TrimSpace(string(out))
	if err != nil {
		return output, fmt.Errorf("kubectl %s failed: %w\n%s", strings.Join(args, " "), err, output)
	}
	return output, nil
}

// KubectlGet runs: kubectl get <resource> -n <namespace> [extraArgs...]
func KubectlGet(kubeContext, namespace, resource string, extraArgs ...string) (string, error) {
	args := []string{"get", resource, "-n", namespace}
	args = append(args, extraArgs...)
	return Kubectl(kubeContext, args...)
}

// KubectlGetJsonpath runs: kubectl get <resource> <name> -n <namespace> -o jsonpath=<expr>
func KubectlGetJsonpath(kubeContext, namespace, resource, name, jsonpath string) (string, error) {
	return Kubectl(kubeContext, "get", resource, name, "-n", namespace,
		"-o", fmt.Sprintf("jsonpath=%s", jsonpath))
}

// KubectlLogs runs: kubectl logs -n <namespace> -l <labelSelector> --tail=<tail>
func KubectlLogs(kubeContext, namespace, labelSelector string, tail int) (string, error) {
	return Kubectl(kubeContext, "logs", "-n", namespace, "-l", labelSelector,
		"--tail", fmt.Sprintf("%d", tail))
}

// KubectlRolloutRestart runs: kubectl rollout restart <resource> -n <namespace>
// and then waits for the rollout to complete.
func KubectlRolloutRestart(kubeContext, namespace, resource string) error {
	if _, err := Kubectl(kubeContext, "rollout", "restart", resource, "-n", namespace); err != nil {
		return err
	}
	_, err := Kubectl(kubeContext, "rollout", "status", resource, "-n", namespace, "--timeout=120s")
	return err
}

// KubectlExec runs: kubectl exec <pod> -n <namespace> [-c <container>] -- <command...>
func KubectlExec(kubeContext, namespace, pod, container string, command ...string) (string, error) {
	args := []string{"exec", pod, "-n", namespace}
	if container != "" {
		args = append(args, "-c", container)
	}
	args = append(args, "--")
	args = append(args, command...)
	return Kubectl(kubeContext, args...)
}

// KubectlExecByLabel finds a Running pod by label selector and execs a command in it.
// This is useful for OC-managed pods whose names are generated by Deployments.
func KubectlExecByLabel(kubeContext, namespace, labelSelector, container string, command ...string) (string, error) {
	podName, err := Kubectl(kubeContext,
		"get", "pod", "-n", namespace,
		"-l", labelSelector,
		"--field-selector=status.phase=Running",
		"-o", "jsonpath={.items[0].metadata.name}",
	)
	if err != nil {
		return "", fmt.Errorf("failed to query running pod for selector %q in %s: %w", labelSelector, namespace, err)
	}
	if podName == "" {
		return "", fmt.Errorf("no running pod found for selector %q in %s", labelSelector, namespace)
	}
	return KubectlExec(kubeContext, namespace, podName, container, command...)
}

// kubectlWithStdin pipes stdinContent to kubectl with the given arguments.
func kubectlWithStdin(kubeContext, stdinContent string, args ...string) (string, error) {
	cmdArgs := append([]string{"--context", kubeContext}, args...)
	cmd := exec.Command("kubectl", cmdArgs...)
	cmd.Stdin = bytes.NewBufferString(stdinContent)
	fmt.Fprintf(GinkgoWriter, "running: kubectl %s (with stdin)\n", strings.Join(cmdArgs, " "))
	out, err := cmd.CombinedOutput()
	output := strings.TrimSpace(string(out))
	if err != nil {
		return output, fmt.Errorf("kubectl %s failed: %w\n%s", strings.Join(args, " "), err, output)
	}
	return output, nil
}

// KubectlApplyLiteral pipes yamlContent to: kubectl apply -f -
func KubectlApplyLiteral(kubeContext, yamlContent string) (string, error) {
	return kubectlWithStdin(kubeContext, yamlContent, "apply", "-f", "-")
}

// KubectlDeleteLiteral pipes yamlContent to: kubectl delete --ignore-not-found -f -
func KubectlDeleteLiteral(kubeContext, yamlContent string) (string, error) {
	return kubectlWithStdin(kubeContext, yamlContent, "delete", "--ignore-not-found", "-f", "-")
}
