{{- if .Values.thunder.enabled }}
{{- if .Values.thunder.bootstrap.enabled }}
{{- $scheme := ternary "http" "https" .Values.thunder.configuration.server.httpOnly }}
{{- $curlInsecure := ternary "" "-k" .Values.thunder.configuration.server.httpOnly }}
{{- $thunderUrl := printf "%s://%s.%s.svc.cluster.local:%d" $scheme (include "openchoreo-control-plane.thunder.name" .) .Release.Namespace (int .Values.thunder.configuration.server.port) }}
apiVersion: v1
kind: ConfigMap
metadata:
  name: thunder-update-backstage-script
  namespace: {{ .Release.Namespace }}
  labels:
    {{- include "openchoreo-control-plane.labels" . | nindent 4 }}
    app.kubernetes.io/component: thunder-update-hook
  annotations:
    "helm.sh/hook": post-upgrade
    "helm.sh/hook-weight": "5"
    "helm.sh/hook-delete-policy": before-hook-creation, hook-succeeded
data:
  update-backstage.sh: |
    #!/bin/bash
    set -e

    # Helper function for logging
    log_info() {
      echo "[INFO] $1"
    }

    # Authenticate using Backstage client credentials
    log_info "Authenticating with Thunder using client credentials..."
    TOKEN_RESPONSE=$(curl {{ $curlInsecure }} -s --max-time 10 '{{ $thunderUrl }}/oauth2/token' \
      --header 'Content-Type: application/x-www-form-urlencoded' \
      --data-urlencode 'grant_type=client_credentials' \
      --data-urlencode 'client_id={{ .Values.backstage.auth.clientId }}' \
      --data-urlencode 'client_secret={{ .Values.backstage.auth.clientSecret }}' \
      --data-urlencode 'scope=system')

    # Extract access token
    ACCESS_TOKEN=$(echo "$TOKEN_RESPONSE" | grep -o '"access_token":"[^"]*"' | cut -d'"' -f4)

    if [ -z "$ACCESS_TOKEN" ]; then
      echo "[ERROR] Failed to obtain access token. Response: $TOKEN_RESPONSE"
      exit 1
    fi

    log_info "Successfully authenticated with Thunder"

    log_info "Checking if application 'Backstage' already exists..."
    existing_apps=$(curl {{ $curlInsecure }} -s --max-time 10 '{{ $thunderUrl }}/applications' \
      --header "Authorization: Bearer $ACCESS_TOKEN")

    # Extract application ID for the Backstage application specifically using jq
    app_id=$(echo "$existing_apps" | jq -r '.applications[] | select(.name=="Backstage") | .id')

    # Define desired redirect URIs
    DESIRED_REDIRECT_URIS='[
      {{- if .Values.backstage.auth.redirectUrls }}
      {{- range $index, $url := .Values.backstage.auth.redirectUrls }}
      {{- if $index }},{{ end }}
      "{{ $url }}"
      {{- end }}
      {{- else }}
      "{{ .Values.backstage.baseUrl | trimSuffix "/" }}/api/auth/openchoreo-auth/handler/frame"
      {{- end }}
    ]'

    if echo "$existing_apps" | grep -q '"name":"Backstage"'; then
      log_info "Application 'Backstage' already exists (id: $app_id), checking if update needed..."

      # Get current application config
      current_app=$(curl {{ $curlInsecure }} -s --max-time 10 "{{ $thunderUrl }}/applications/$app_id" \
        --header "Authorization: Bearer $ACCESS_TOKEN")

      # Extract current redirect URIs for comparison
      current_redirects=$(echo "$current_app" | grep -o '"redirect_uris":\[[^]]*\]' | tr -d '[:space:]')
      desired_redirects_normalized=$(echo "$DESIRED_REDIRECT_URIS" | tr -d '[:space:]')

      if [ "$current_redirects" = "\"redirect_uris\":$desired_redirects_normalized" ]; then
        log_info "Redirect URIs unchanged, skipping update"
      else
        log_info "Redirect URIs changed, updating application..."

        # Prepare payload: remove id field and update redirect_uris
        # Remove the id field from the JSON
        APP_PAYLOAD=$(echo "$current_app" | sed 's/"id":"[^"]*",\?//')

        # Replace redirect_uris with desired values
        # This finds the redirect_uris array and replaces it with our desired URIs
        APP_PAYLOAD=$(echo "$APP_PAYLOAD" | sed "s|\"redirect_uris\":\[[^]]*\]|\"redirect_uris\":$desired_redirects_normalized|")

        # Update client secret in inbound_auth_config for oauth2
        # This uses jq to properly update the nested JSON structure
        APP_PAYLOAD=$(echo "$APP_PAYLOAD" | jq --arg secret "$BACKSTAGE_CLIENT_SECRET" '
          .inbound_auth_config |= map(
            if .type == "oauth2" then
              .config.client_secret = $secret
            else
              .
            end
          )
        ')

        curl {{ $curlInsecure }} --location -X PUT "{{ $thunderUrl }}/applications/$app_id" \
          --header 'Content-Type: application/json' \
          --header "Authorization: Bearer $ACCESS_TOKEN" \
          --data "$APP_PAYLOAD" \
          --fail-with-body \
          --max-time 30 \
          --retry 3 \
          --retry-delay 5

        log_info "Application updated successfully"
      fi
    else
      log_info "Application 'Backstage' does not exist. Skipping update (should be created during bootstrap)."
    fi
---
apiVersion: batch/v1
kind: Job
metadata:
  name: thunder-update-backstage
  namespace: {{ .Release.Namespace }}
  labels:
    {{- include "openchoreo-control-plane.labels" . | nindent 4 }}
    app.kubernetes.io/component: thunder-update-hook
  annotations:
    "helm.sh/hook": post-upgrade
    "helm.sh/hook-weight": "10"
    "helm.sh/hook-delete-policy": before-hook-creation, hook-succeeded
spec:
  backoffLimit: {{ .Values.thunder.setup.backoffLimit | default 3 }}
  template:
    metadata:
      labels:
        {{- include "openchoreo-control-plane.labels" . | nindent 8 }}
        app.kubernetes.io/component: thunder-update-hook
    spec:
      restartPolicy: Never
      serviceAccountName: {{ .Values.thunder.serviceAccount.name }}
      containers:
      - name: update-backstage
        image: alpine:3.21
        env:
        - name: BACKSTAGE_CLIENT_SECRET
          valueFrom:
            secretKeyRef:
              name: {{ include "openchoreo-control-plane.backstage.secretName" . }}
              key: client-secret
        command:
        - /bin/sh
        - -c
        - |
          # Install required tools
          echo "[INFO] Installing curl and jq..."
          apk add --no-cache curl jq

          # Wait for Thunder to be ready
          echo "[INFO] Waiting for Thunder service to be ready..."
          MAX_RETRIES=30
          RETRY_COUNT=0
          while [ $RETRY_COUNT -lt $MAX_RETRIES ]; do
            if curl {{ $curlInsecure }} -s --max-time 5 '{{ $thunderUrl }}/health' > /dev/null 2>&1; then
              echo "[INFO] Thunder service is ready"
              break
            fi
            echo "[INFO] Thunder not ready yet, waiting... (attempt $((RETRY_COUNT + 1))/$MAX_RETRIES)"
            sleep 10
            RETRY_COUNT=$((RETRY_COUNT + 1))
          done

          if [ $RETRY_COUNT -eq $MAX_RETRIES ]; then
            echo "[ERROR] Thunder service did not become ready in time"
            exit 1
          fi

          # Run the update script
          /bin/sh /scripts/update-backstage.sh
        volumeMounts:
        - name: script
          mountPath: /scripts
        resources:
          {{- toYaml .Values.thunder.setup.resources | nindent 10 }}
        securityContext:
          # Run as root for package installation, with strict security controls
          runAsUser: 0
          runAsNonRoot: false
          allowPrivilegeEscalation: false
          readOnlyRootFilesystem: false
          capabilities:
            drop:
            - ALL
          seccompProfile:
            type: RuntimeDefault
      volumes:
      - name: script
        configMap:
          name: thunder-update-backstage-script
          defaultMode: 0755
{{- end }}
{{- end }}
