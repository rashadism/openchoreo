{{ if .Values.global.defaultResources.enabled }}
apiVersion: argoproj.io/v1alpha1
kind: ClusterWorkflowTemplate
metadata:
  name: react
  annotations:
    "helm.sh/hook": post-install,post-upgrade
    "helm.sh/hook-weight": "15"
    "helm.sh/delete-policy": hook-failed
  labels:
    {{- include "openchoreo-build-plane.labels" . | nindent 4 }}
spec:
  entrypoint: build-workflow
  arguments:
    parameters:
      - name: node-version
  templates:
    - name: build-workflow
      steps:
        - - name: checkout-source
            template: checkout-source
        - - name: build-image
            template: build-image
            arguments:
              parameters:
                - name: git-revision
                  value: '{{ "{{" }}steps.checkout-source.outputs.parameters.git-revision{{ "}}" }}'
        - - name: publish-image
            template: publish-image
            arguments:
              parameters:
                - name: git-revision
                  value: '{{ "{{" }}steps.checkout-source.outputs.parameters.git-revision{{ "}}" }}'
        - - name: generate-workload-cr
            template: generate-workload-cr
            arguments:
              parameters:
                - name: image
                  value: '{{ "{{" }}steps.publish-image.outputs.parameters.image{{ "}}" }}'
    - name: checkout-source
      outputs:
        parameters:
          - name: git-revision
            valueFrom:
              path: /tmp/git-revision.txt
      volumes:
        - name: git-secret
          secret:
            secretName: '{{ "{{" }}workflow.parameters.git-secret{{ "}}" }}'
            optional: true
      container:
        args:
          - |-
            set -e

            #####################################################################
            # 1. Initialize variables
            #####################################################################
            BRANCH={{ "{{" }}workflow.parameters.branch{{ "}}" }}
            REPO={{ "{{" }}workflow.parameters.git-repo{{ "}}" }}
            COMMIT={{ "{{" }}workflow.parameters.commit{{ "}}" }}
            GIT_SECRET_PATH="/etc/secrets/git-secret"

            #####################################################################
            # 2. Configure Git Authentication
            #####################################################################

            # Check if git secret exists (for private repositories)
            if [ -d "$GIT_SECRET_PATH" ] && [ "$(ls -A $GIT_SECRET_PATH)" ]; then
                echo "Git secret found, configuring authentication..."

                # Check for SSH key (kubernetes.io/ssh-auth)
                # Supports all SSH key types: RSA, Ed25519, ECDSA, DSA
                if [ -f "$GIT_SECRET_PATH/ssh-privatekey" ]; then
                    echo "Using SSH key authentication"
                    mkdir -p ~/.ssh
                    chmod 700 ~/.ssh

                    # Copy SSH key ensuring proper format and Unix line endings
                    # Note: filename is id_rsa by convention, but SSH supports all key types
                    # (RSA, Ed25519, ECDSA) regardless of filename
                    # Remove Windows line endings if present and ensure Unix format
                    tr -d '\r' < "$GIT_SECRET_PATH/ssh-privatekey" > ~/.ssh/id_rsa
                    # Ensure key ends with a newline if it doesn't already
                    [ -n "$(tail -c 1 ~/.ssh/id_rsa)" ] && echo >> ~/.ssh/id_rsa
                    chmod 600 ~/.ssh/id_rsa

                    # Validate key format
                    if ! grep -q "BEGIN.*PRIVATE KEY" ~/.ssh/id_rsa; then
                        echo "Error: SSH key does not appear to be valid (missing BEGIN PRIVATE KEY header)"
                        head -n 1 ~/.ssh/id_rsa
                        exit 1
                    fi

                    # Debug: Show key type and verify it's readable
                    echo "SSH key format detected:"
                    head -n 1 ~/.ssh/id_rsa

                    # Test if ssh can load the key
                    if ! ssh-keygen -l -f ~/.ssh/id_rsa > /dev/null 2>&1; then
                        echo "Warning: SSH key validation failed with ssh-keygen"
                        echo "This might indicate key format issues, but attempting to proceed..."
                    else
                        echo "SSH key validated successfully"
                    fi

                    # Read SSH Key ID if available (required for AWS CodeCommit)
                    SSH_KEY_ID=""
                    if [ -f "$GIT_SECRET_PATH/ssh-key-id" ]; then
                        SSH_KEY_ID=$(cat "$GIT_SECRET_PATH/ssh-key-id")
                        echo "SSH Key ID found: $SSH_KEY_ID"
                    fi

                    # Disable strict host key checking for common git providers
                    cat > ~/.ssh/config <<EOF
            Host github.com
                StrictHostKeyChecking no
                UserKnownHostsFile /dev/null
            Host gitlab.com
                StrictHostKeyChecking no
                UserKnownHostsFile /dev/null
            Host bitbucket.org
                StrictHostKeyChecking no
                UserKnownHostsFile /dev/null
            Host git-codecommit.*.amazonaws.com
                StrictHostKeyChecking no
                UserKnownHostsFile /dev/null
            EOF
                    chmod 600 ~/.ssh/config

                    # Handle SSH URL conversion and AWS CodeCommit SSH Key ID
                    if echo "$REPO" | grep -q "^ssh://.*git-codecommit"; then
                        # SSH URL for AWS CodeCommit - inject SSH Key ID if available and not already present
                        if [ -n "$SSH_KEY_ID" ] && ! echo "$REPO" | grep -q "@"; then
                            REPO=$(echo "$REPO" | sed "s|ssh://|ssh://${SSH_KEY_ID}@|")
                            echo "Added SSH Key ID to AWS CodeCommit SSH URL"
                        fi
                    elif echo "$REPO" | grep -q "^https://" && ! echo "$REPO" | grep -q "git-codecommit"; then
                        # HTTPS URL for GitHub/GitLab/Bitbucket - convert to git@ SSH format
                        REPO=$(echo "$REPO" | sed -E 's|https://([^/]+)/(.+)\.git|git@\1:\2.git|')
                        echo "Converted HTTPS to SSH format: $REPO"
                    fi
                    # Note: HTTPS URLs for AWS CodeCommit are left as-is to use basic-auth (username:password)

                # Check for basic auth (kubernetes.io/basic-auth)
                elif [ -f "$GIT_SECRET_PATH/password" ]; then
                    echo "Using basic authentication (username/password)"
                    PASSWORD=$(cat "$GIT_SECRET_PATH/password")

                    # Check if username exists (required for some providers like AWS CodeCommit)
                    if [ -f "$GIT_SECRET_PATH/username" ]; then
                        USERNAME=$(cat "$GIT_SECRET_PATH/username")
                        echo "Username found: $USERNAME"
                    else
                        # Default username for token-based auth (GitHub, GitLab, Bitbucket)
                        USERNAME="git"
                    fi

                    # Inject credentials into HTTPS URL
                    if echo "$REPO" | grep -q "^https://"; then
                        # Extract protocol, domain, and path
                        PROTOCOL=$(echo "$REPO" | cut -d: -f1)
                        DOMAIN_PATH=$(echo "$REPO" | cut -d/ -f3-)

                        # URL encode username and password (encode all special characters)
                        # This handles characters like: @ : / + = and others that break URLs
                        USERNAME_ENCODED=$(echo -n "$USERNAME" | sed 's/%/%25/g; s/ /%20/g; s/!/%21/g; s/"/%22/g; s/#/%23/g; s/\$/%24/g; s/&/%26/g; s/'\''/%27/g; s/(/%28/g; s/)/%29/g; s/\*/%2A/g; s/+/%2B/g; s/,/%2C/g; s/\//%2F/g; s/:/%3A/g; s/;/%3B/g; s/=/%3D/g; s/?/%3F/g; s/@/%40/g; s/\[/%5B/g; s/\]/%5D/g')
                        PASSWORD_ENCODED=$(echo -n "$PASSWORD" | sed 's/%/%25/g; s/ /%20/g; s/!/%21/g; s/"/%22/g; s/#/%23/g; s/\$/%24/g; s/&/%26/g; s/'\''/%27/g; s/(/%28/g; s/)/%29/g; s/\*/%2A/g; s/+/%2B/g; s/,/%2C/g; s/\//%2F/g; s/:/%3A/g; s/;/%3B/g; s/=/%3D/g; s/?/%3F/g; s/@/%40/g; s/\[/%5B/g; s/\]/%5D/g')

                        # Construct authenticated URL
                        REPO="$PROTOCOL://${USERNAME_ENCODED}:${PASSWORD_ENCODED}@${DOMAIN_PATH}"
                    else
                        echo "Warning: REPO is not an HTTPS URL, basic auth may not work"
                    fi

                    # Configure git credential helper to avoid credential prompts
                    git config --global credential.helper store
                else
                    echo "Warning: Git secret exists but no recognized credentials found"
                fi
            else
                echo "No git secret found, assuming public repository"
            fi

            #####################################################################
            # 3. Clone Repository
            #####################################################################

            if [ -n "$COMMIT" ]; then
                echo "Cloning specific commit: $COMMIT"
                git clone --no-checkout --depth 1 "$REPO" /mnt/vol/source
                cd /mnt/vol/source
                git config --global advice.detachedHead false
                git fetch --depth 1 origin "$COMMIT"
                git checkout "$COMMIT"
                echo -n "$COMMIT" | cut -c1-8 > /tmp/git-revision.txt
            else
                echo "Cloning branch: $BRANCH with latest commit"
                git clone --single-branch --branch $BRANCH --depth 1 "$REPO" /mnt/vol/source
                cd /mnt/vol/source
                COMMIT_SHA=$(git rev-parse HEAD)
                echo -n "$COMMIT_SHA" | cut -c1-8 > /tmp/git-revision.txt
            fi

            echo "Repository cloned successfully"
        command:
          - sh
          - -c
        image: alpine/git
        name: ""
        volumeMounts:
          - mountPath: /mnt/vol
            name: workspace
          - mountPath: /etc/secrets/git-secret
            name: git-secret
            readOnly: true
    - name: build-image
      inputs:
        parameters:
          - name: git-revision
      container:
        args:
          - |-
            set -e

            WORKDIR="/mnt/vol/source"

            IMAGE="{{ "{{" }}workflow.parameters.image-name{{ "}}" }}:{{ "{{" }}workflow.parameters.image-tag{{ "}}" }}-{{ "{{" }}inputs.parameters.git-revision{{ "}}" }}"
            APP_PATH="{{ "{{" }}workflow.parameters.app-path{{ "}}" }}"
            NODE_VERSION="{{ "{{" }}workflow.parameters.node-version{{ "}}" }}"

            #####################################################################
            # 1. Prepare workspace and locate source
            #####################################################################
            cd "${WORKDIR}"

            # Remove leading slash from APP_PATH if present
            APP_PATH_CLEAN=$(echo "$APP_PATH" | sed 's|^/||')

            # Determine source directory - if APP_PATH is specified, use it, otherwise use current directory
            if [ -n "$APP_PATH_CLEAN" ] && [ -d "$APP_PATH_CLEAN" ]; then
                SOURCE_DIR="$APP_PATH_CLEAN"
            else
                SOURCE_DIR="."
            fi

            echo "Building from source directory: $SOURCE_DIR"
            #####################################################################
            # 2. Build React: Custom Dockerfile + Nginx
            #####################################################################
            cat > "${SOURCE_DIR}/Dockerfile" <<EOF
            FROM node:${NODE_VERSION}-alpine AS builder
            RUN npm install -g pnpm
            WORKDIR /app
            COPY . .
            RUN if [ -f "package-lock.json" ]; then npm ci; \\
                elif [ -f "yarn.lock" ]; then yarn install --frozen-lockfile; \\
                elif [ -f "pnpm-lock.yaml" ]; then pnpm install --frozen-lockfile; \\
                else echo "No lock file found" && exit 1; fi
            RUN npm run build || yarn run build || pnpm run build

            FROM nginx:alpine
            COPY --from=builder /app/default.conf /etc/nginx/conf.d/default.conf
            COPY --from=builder /app/build /usr/share/nginx/html/
            EOF

            cat > "${SOURCE_DIR}/default.conf" <<'EOF'
            server {
              listen 80;
              location / {
                root   /usr/share/nginx/html;
                index  index.html;
                try_files $uri /index.html;
              }
            }
            EOF

            podman build -t "$IMAGE" -f "${SOURCE_DIR}/Dockerfile" "$SOURCE_DIR"
            podman save -o /mnt/vol/app-image.tar "$IMAGE"
        command:
          - sh
          - -c
        image: ghcr.io/openchoreo/podman-runner:v1.0
        securityContext:
          privileged: true
        volumeMounts:
          - mountPath: /mnt/vol
            name: workspace
    - name: publish-image
      inputs:
        parameters:
          - name: git-revision
      outputs:
        parameters:
          - name: image
            valueFrom:
              path: /tmp/image.txt
      volumes:
        - name: registry-push-secret
          secret:
            optional: true
            secretName: '{{ "{{" }}workflow.parameters.registry-push-secret{{ "}}" }}'
      container:
        args:
          - |-
            set -e

            #####################################################################
            # 1. Inputs
            #####################################################################
            GIT_REVISION={{ "{{" }}inputs.parameters.git-revision{{ "}}" }}
            IMAGE_NAME={{ "{{" }}workflow.parameters.image-name{{ "}}" }}
            IMAGE_TAG={{ "{{" }}workflow.parameters.image-tag{{ "}}" }}
            SRC_IMAGE="${IMAGE_NAME}:${IMAGE_TAG}-${GIT_REVISION}"

            #####################################################################
            # 2. Registry
            #####################################################################
            REGISTRY_ENDPOINT="{{ include "openchoreo-build-plane.registryEndpoint" . }}"
            AUTH_FILE="/etc/secrets/registry-push-secret/.dockerconfigjson"

            #####################################################################
            # 3. Podman storage configuration
            #####################################################################
            mkdir -p /etc/containers
            cat <<EOF > /etc/containers/storage.conf
            [storage]
            driver = "overlay"
            runroot = "/run/containers/storage"
            graphroot = "/var/lib/containers/storage"
            [storage.options.overlay]
            mount_program = "/usr/bin/fuse-overlayfs"
            EOF

            #####################################################################
            # 4. Load the tarred image and push to registry
            #####################################################################
            podman load -i /mnt/vol/app-image.tar

            podman tag $SRC_IMAGE $REGISTRY_ENDPOINT/$SRC_IMAGE

            if [ -f "$AUTH_FILE" ]; then
              podman push --tls-verify={{ .Values.global.defaultResources.registry.tlsVerify }} --authfile "$AUTH_FILE" $REGISTRY_ENDPOINT/$SRC_IMAGE
            else
              podman push --tls-verify={{ .Values.global.defaultResources.registry.tlsVerify }} $REGISTRY_ENDPOINT/$SRC_IMAGE
            fi

            #####################################################################
            # 5. Emit image reference (for later steps/kubelet pulls)
            #####################################################################
            echo -n "$REGISTRY_ENDPOINT/$SRC_IMAGE" > /tmp/image.txt

        command:
          - sh
          - -c
        image: ghcr.io/openchoreo/podman-runner:v1.0
        securityContext:
          privileged: true
        volumeMounts:
          - mountPath: /mnt/vol
            name: workspace
          - mountPath: /etc/secrets/registry-push-secret
            name: registry-push-secret
            readOnly: true
    - name: generate-workload-cr
      inputs:
        parameters:
          - name: image
      outputs:
        parameters:
          - name: workload-cr
            valueFrom:
              path: /mnt/vol/workload-cr.yaml
      container:
        image: ghcr.io/openchoreo/podman-runner:v1.0
        command: [ sh, -c ]
        args:
          - |-
            set -e

            #####################################################################
            # 1. Initialize variables
            #####################################################################
            IMAGE={{ "{{" }}inputs.parameters.image{{ "}}" }}
            PROJECT_NAME={{ "{{" }}workflow.parameters.project-name{{ "}}" }}
            COMPONENT_NAME={{ "{{" }}workflow.parameters.component-name{{ "}}" }}
            APP_PATH="{{ "{{" }}workflow.parameters.app-path{{ "}}" }}"

            DESCRIPTOR_PATH="/mnt/vol/source${APP_PATH:+/${APP_PATH#/}}"

            OUTPUT_PATH="/mnt/vol/workload-cr.yaml"

            echo "Creating workload with image: ${IMAGE}"
            echo "Using descriptor in: ${DESCRIPTOR_PATH}"

            #####################################################################
            # 2. Podman storage configuration
            #####################################################################
            mkdir -p /etc/containers
            cat <<EOF > /etc/containers/storage.conf
            [storage]
            driver = "overlay"
            runroot = "/run/containers/storage"
            graphroot = "/var/lib/containers/storage"
            [storage.options.overlay]
            mount_program = "/usr/bin/fuse-overlayfs"
            EOF

            #####################################################################
            # 3. Create workload CR and export to output
            #####################################################################
            # Check if workload.yaml exists and build the command accordingly
            if [ -f "${DESCRIPTOR_PATH}/workload.yaml" ]; then
              echo "Found workload.yaml descriptor, using it for workload creation"
              podman run --rm --network=none \
              -v $DESCRIPTOR_PATH:/app:rw -w /app \
              ghcr.io/openchoreo/openchoreo-cli:{{ .Chart.AppVersion }} \
                workload create \
                --project "${PROJECT_NAME}" \
                --component "${COMPONENT_NAME}" \
                --image "${IMAGE}" \
                --descriptor "workload.yaml" \
                -o "workload-cr.yaml"
            else
              echo "No workload.yaml descriptor found, creating workload without descriptor"
              podman run --rm --network=none \
              -v $DESCRIPTOR_PATH:/app:rw -w /app \
              ghcr.io/openchoreo/openchoreo-cli:{{ .Chart.AppVersion }} \
                workload create \
                --project "${PROJECT_NAME}" \
                --component "${COMPONENT_NAME}" \
                --image "${IMAGE}" \
                -o "workload-cr.yaml"
            fi

            # Copy output CR to the shared volume
            cp -f "${DESCRIPTOR_PATH}/workload-cr.yaml" "${OUTPUT_PATH}"
        volumeMounts:
          - name: workspace
            mountPath: /mnt/vol
        securityContext:
          privileged: true
  ttlStrategy:
    secondsAfterCompletion: 3600
  volumeClaimTemplates:
    - metadata:
        creationTimestamp: null
        name: workspace
      spec:
        accessModes:
          - ReadWriteOnce
        resources:
          requests:
            storage: 2Gi
{{ end }}
